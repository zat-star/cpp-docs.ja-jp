---
title: "タイム クリティカルなコードを高速化するためのヒント | Microsoft Docs"
ms.custom: ""
ms.date: "11/04/2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
helpviewer_keywords: 
  - "_lfind 関数"
  - "_lsearch 関数"
  - "バックグラウンド タスク"
  - "推奨される手順, タイム クリティカル コード"
  - "bsearch 関数"
  - "キャッシュ [C++], ヒットとミス"
  - "クロック分の損失"
  - "コード, タイム クリティカル"
  - "実行, 速度の向上"
  - "ヒープ割り当て, タイム クリティカル コードのパフォーマンス"
  - "リニア サーチのパフォーマンス"
  - "一覧, 並べ替え"
  - "ローカル ヒープのパフォーマンス"
  - "メモリ [C++], 監視 (使用率を)"
  - "MFC [C++], パフォーマンス"
  - "最適化 [C++], タイム クリティカル コード"
  - "ページ フォールト"
  - "パフォーマンス [C++], タイム クリティカル コード"
  - "プログラム [C++], パフォーマンス"
  - "qsort 関数"
  - "検索 [C++], 向上 (パフォーマンスを)"
  - "並べ替えルーチン"
  - "並べ替え (データの), 向上 (パフォーマンスを)"
  - "標準並べ替えルーチン"
  - "スレッド処理 [C++], バックグラウンド タスク"
  - "スレッド処理 [C++], 推奨される手順"
  - "スレッド処理 [C++], パフォーマンス"
ms.assetid: 3e95a8cc-6239-48d1-9d6d-feb701eccb54
caps.latest.revision: 8
author: "corob-msft"
ms.author: "corob"
manager: "ghogen"
caps.handback.revision: 8
---
# タイム クリティカルなコードを高速化するためのヒント
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

実行が速いコードを書くには、アプリケーションのすべての側面およびシステムとのやり取りを理解する必要があります。  このトピックでは、コードのタイム クリティカルな部分が満足に機能するよう、よく知られたコーディング テクニックの代わりとなるものを提案します。  
  
 要約すると、タイム クリティカルなコードを改善するには、次を行う必要があります。  
  
-   プログラムのどの部分を高速にする必要があるかを知る。  
  
-   コードのサイズと速度を知る。  
  
-   新しい機能のコストを知る。  
  
-   ジョブを完了するために必要な最小限の作業を知る。  
  
 コードのパフォーマンスに関する情報を収集するには、パフォーマンス モニター \(perfmon.exe\) を使うことができます。  
  
## この記事のセクション  
  
-   [キャッシュ ミスとページ フォールト](#_core_cache_hits_and_page_faults)  
  
-   [並べ替えと検索](#_core_sorting_and_searching)  
  
-   [MFC とクラス ライブラリ](#_core_mfc_and_class_libraries)  
  
-   [共有ライブラリ](#vcovrsharedlibraries)  
  
-   [ヒープ](#_core_heaps)  
  
-   [スレッド](#_core_threads)  
  
-   [小さな作業セット](#_core_small_working_set)  
  
##  <a name="_core_cache_hits_and_page_faults"></a> キャッシュ ミスとページ フォールト  
 ミスしたキャッシュ ヒット \(内部および外部キャッシュの両方\) およびページ フォールト \(プログラムの命令とデータのために 2 次的なストレージに行く\) は、プログラムのパフォーマンスを遅らせます。  
  
 CPU キャッシュ ヒットでは、プログラムで 10 ～ 20 クロック サイクルが必要になります。  外部キャッシュ ヒットでは、20 ～ 40 クロック サイクルが必要になります。  ページ フォールトでは、100 万クロック サイクルが必要になります \(プロセッサが毎秒 500 万回の命令を処理し、ページ フォールトで 2 ミリ秒を要したと仮定\)。  そのため、キャッシュ ヒットのミスやページ フォールトの数を減らすコードを書くことが、プログラムの実行に大きく役立ちます。  
  
 プログラムが遅いことの一因に、必要以上にページ フォールトの回数やキャッシュ ミスの回数が多いことがあります。  これを避けるには、参照場所が整理されたデータ構造にする、つまり関連データを一緒にしておくことが重要です。  データ構造が優れているように見えても、参照場所が良くないため、実は劣った構造であったり、その逆もあります。  2 つの例を挙げます。  
  
-   動的に割り当てられたリンク リストは、プログラムのパフォーマンスを低下させる可能性があります。項目を検索したり、リストの最後まで走査したりすると、スキップされた各リンクでキャッシュ ミスやページ フォールトが生じることがあるからです。  単純な配列に基づいたリストの導入のほうが大幅に速い場合があります。キャッシュが優れ、ページ フォールトが少ないからです。配列の拡張が難しい点を考慮に入れても、より速い可能性があります。  
  
-   動的に割り当てられたリンク リストを使うハッシュ テーブルはパフォーマンスを低下させる可能性があります。  その延長で、動的に割り当てられたリンク リストを使ってコンテンツを保存するハッシュ テーブルは、パフォーマンスがさらに劣る可能性があります。  最終的には、配列を使った単純な一方向の検索のほうが実際には速い場合があります \(状況に応じて\)。  配列ベースのハッシュ テーブル \(いわゆる「クローズド ハッシュ」\) は、導入が見過ごされがちですが、多くの場合パフォーマンスが優れています。  
  
##  <a name="_core_sorting_and_searching"></a> 並べ替えと検索  
 並べ替えは、多くの一般的な操作と比べて本質的に時間がかかります。  不必要な遅延を避ける最善の方法は、重要な時間帯に並べ替えを避けることです。  次を行うことができます。  
  
-   パフォーマンスに重要な影響が及ばない時間帯になるまで並べ替えを待つ。  
  
-   前もってパフォーマンスに重要な影響が及ばない時間帯にデータを並べ替える。  
  
-   並べ替えが本当に必要な部分だけデータを並べ替える。  
  
 並べ替えられた順番でリストをビルドできる場合があります。  ただし、並べ替えられた順番でデータを挿入する必要がある場合、より複雑なデータ構造が必要となって参照場所の配置が悪くなる可能性があり、キャッシュ ミスやページ フォールトにつながるため注意する必要があります。  すべての場面で効果的な単一の方法はありません。  いくつかの方法を試してみて、違いを測定します。  
  
 並べ替えに関する一般的なヒントを次に示します。  
  
-   ストックの並べ替えを使ってバグを最小限にします。  
  
-   並べ替えの複雑さを軽減するために事前に行える作業は、実行する価値があります。  データのワンタイム パスによって比較が単純化され、並べ替えが O\(n log n\) から O\(n\) に減る場合、ほとんどの場合に効率が上がります。  
  
-   並べ替えアルゴリズムの参照場所と実行対象のデータについて考えます。  
  
 検索の場合、並べ替えと比べて代替方法が少なくなります。  検索がタイム クリティカルな場合、バイナリ検索またはハッシュ テーブル ルックアップがほとんどいつも最善の方法となりますが、並べ替えの場合と同じく、場所も考慮する必要があります。  多くのポインターがあってページ フォールトやキャッシュ ミスが生じるデータ構造でのバイナリ検索よりも、小さな配列の一方向の検索のほうが速くなる場合があります。  
  
##  <a name="_core_mfc_and_class_libraries"></a> MFC とクラス ライブラリ  
 Microsoft Foundation Classes \(MFC\) は、コードの作成を大幅に簡略化します。  タイム クリティカルなコードを作成する場合、一部のクラスに特有のオーバーヘッドについて理解する必要があります。  タイム クリティカルなコードが使用する MFC コードがパフォーマンス要件を満たしているかどうか確認します。  次は、知っておく必要のある MFC クラスと関数の一覧です。  
  
-   `CString` MFC は C ランタイム ライブラリを呼び出して、[CString](../../atl-mfc-shared/reference/cstringt-class.md) にメモリを動的に割り当てます。  一般に、`CString` の効率は、他の動的に割り当てられる文字列と同等です。  また他の動的に割り当てられた文字列と同様に、動的な割り当てとリリースのオーバーヘッドがあります。  多くの場合、スタックの単純な `char` 配列は同じ用途を速く行うことができます。  定数文字列を保存するのに `CString` は使用しません。  代わりに、`const char *` を使用してください。  `CString` オブジェクトで行う操作には何らかのオーバーヘッドがあります。  ランタイム ライブラリの[文字列機能](../../c-runtime-library/string-manipulation-crt.md)を使用するほうが速い可能性があります。  
  
-   `CArray` [CArray](../../mfc/reference/carray-class.md) は通常の配列にない柔軟性を提供しますが、使用するプログラムでは必要ない可能性があります。  配列に特定の制限があることを知っている場合、代わりにグローバル固定配列を使用できます。  `CArray` を使用する場合、`CArray::SetSize` を使ってそのサイズを設定し、要素の数を指定します。再割り当てが必要なときにはこれを利用して拡張します。  それ以外の場合、要素を追加すると配列に対して頻繁に再割り当てとコピーが行われるため、非効率的となり、メモリが断片化されます。  また、配列に項目を挿入すると、`CArray` は続く項目をメモリに移動するため、配列を増やす必要が生じる場合があります。  これらの操作によって、キャッシュ ミスやページ フォールトが生じることがあります。  MFC が使用するコードを見直すと、自分のシナリオに応じてより具体的に記述することで、パフォーマンスを向上できる可能性があります。  `CArray` はテンプレートであるため、たとえば特定の型に応じて `CArray` 特殊化することもできます。  
  
-   `CList`  [CList](../../mfc/reference/clist-class.md) はダブルリンク リストです。そのため、要素の挿入はリストの先頭、末尾、および既知の位置 \(`POSITION`\) で速くなります。  要素を値またはインデックスで検索する場合、順次検索が必要となり、リストが長い場合は遅くなります。  コードでダブルリンク リストが必要ないなら、`CList` の使用を再度検討できます。  シングルリンク リストは、すべての操作で追加のポインターを更新するためのオーバーヘッドおよびそのポインターのメモリのオーバーヘッドを減らすことができます。  追加のメモリは多くありませんが、キャッシュ ミスやページ フォールトが生じる余地を与えることになります。  
  
-   `IsKindOf` この機能は、多数の呼び出しを生成し、異なるデータ領域で多くのメモリにアクセスするため、参照場所が劣ってしまう可能性があります。  デバッグ ビルド \(たとえば ASSERT 呼び出し\) で有用ですが、リリース ビルドでは使用しないようにします。  
  
-   `PreTranslateMessage` ウィンドウの特定のツリーが異なるキーボード アクセラレータを必要とする場合、またはメッセージ ポンプにメッセージ処理を挿入する必要がある場合に、`PreTranslateMessage` を使用します。  `PreTranslateMessage` は MFC ディスパッチ メッセージを変えます。  `PreTranslateMessage` をオーバーライドする場合、必要なレベルでのみ行います。  たとえば、特定のビューの子にのみ届くメッセージに関心がある場合、`CMainFrame::PreTranslateMessage` をオーバーライドする必要はありません。  代わりに、ビュー クラスの `PreTranslateMessage` をオーバーライドします。  
  
     任意のウィンドウに送られる任意のメッセージを処理するために `PreTranslateMessage` を使って通常のディスパッチ パスを迂回しないようにします。  その目的用に、[ウィンドウ手順](../../mfc/registering-window-classes.md)および MFC メッセージ マップを使用します。  
  
-   `OnIdle` アイドル イベントは、予期しない時に生じる場合があります。たとえば、`WM_KEYDOWN` イベントと `WM_KEYUP` イベントの間です。  コードをトリガーするには、タイマーのほうがより効果的な場合があります。  偽のメッセージを生成したり、`OnIdle` のオーバーライドから常に `TRUE` を返したりすることによって、繰り返し `OnIdle` を強制的に呼び出すのを避けます。スレッドがスリープできなくなります。  ここでも、タイマーまたは個別のスレッドのほうが適切な場合があります。  
  
##  <a name="vcovrsharedlibraries"></a> 共有ライブラリ  
 望ましいのはコードを再利用することです。  ただし、他人のコードを使用する場合、パフォーマンスが重要な場面でどのように動作するかを正確に把握している必要があります。  それを確かめる最善の方法は、ソース コードに分け入るか、PView やパフォーマンス モニターなどのツールで測定することです。  
  
##  <a name="_core_heaps"></a> ヒープ  
 複数のヒープを思慮深く使用します。  `HeapCreate` および `HeapAlloc` で作成した追加のヒープにより、関連する割り当てのセットを管理し、破棄することができます。  過多のメモリをコミットしないようにします。  複数のヒープを使用する場合、最初にコミットするメモリの量に特に注意します。  
  
 複数のヒープを使用する代わりに、ヘルパー機能を使ってコードと既定のヒープを相互作用させることができます。  ヘルパー機能はカスタム割り当て戦略を促進して、アプリケーションのパフォーマンスを改善することができます。  たとえば、小さな割り当てを頻繁に行う場合、これらの割り当てを既定のヒープの一部にローカライズすることができます。  メモリの大きなブロックを割り当てた後、ヘルパー機能を使ってそのブロックからサブ割り当てすることができます。  そうするなら、割り当ては既定のヒープから来るため、未使用のメモリがある追加のヒープはなくなります。  
  
 ただし、場合によっては既定のヒープを使うことで参照場所を減らせる場合があります。  Process Viewer、Spy\+\+、またはパフォーマンス モニターを使って、オブジェクトをヒープからヒープへ移動させる影響を測定します。  
  
 ヒープを測定して、ヒープ上のすべての割り当てを把握します。  C ランタイムの[デバッグ ヒープ ルーチン](../Topic/CRT%20Debug%20Heap%20Details.md)を使用して、ヒープのチェックポイントとダンプを行います。  出力を Microsoft Excel などのスプレッドシート プログラムに読み込ませ、ピボット テーブルを使って結果を表示できます。  割り当ての合計数、サイズ、および分布を確認します。  これらを、作業セットのサイズと比較します。  また、関連サイズのオブジェクトのクラスタリングも確認します。  
  
 さらに、パフォーマンス カウンターでメモリの使用量を監視できます。  
  
##  <a name="_core_threads"></a> スレッド  
 バックグラウンド タスクの場合、スレッドを使用するよりも、イベントの効果的なアイドル処理のほうが速い可能性があります。  シングル スレッド プログラムのほうが参照場所を理解しやすくなります。  
  
 経験則として、ブロックするオペレーティング システムの通知がバックグラウンド作業のルートにある場合にのみ、スレッドを使用します。  そのような場合、イベントでメイン スレッドをブロックするのは実際的でないため、スレッドが最適なソリューションとなります。  
  
 また、スレッドは通信問題を引き起こす場合があります。  メッセージのリストまたは共有メモリの割り当てと使用によって、スレッド間の通信リンクを管理する必要があります。  通信リンクの管理には、競合状態やデッドロック問題を回避するために、通常は同期が必要です。  この複雑さのせいで、バグやパフォーマンスの問題が簡単に生じ得ます。  
  
 詳細については、「[アイドル ループ プロセシング](../Topic/Idle%20Loop%20Processing.md)」および「[マルチスレッド](../../parallel/multithreading-support-for-older-code-visual-cpp.md)」を参照してください。  
  
##  <a name="_core_small_working_set"></a> 小さな作業セット  
 作業セットが小さいと、参照場所が向上し、ページ フォールトが少なくなり、キャッシュ ヒットが増えます。  プロセス作業セットは、オペレーティング システムが参照場所を測定するために直接提供する最も近いメトリックです。  
  
-   作業セットの上限と下限を設定するには、[SetProcessWorkingSetSize](http://msdn.microsoft.com/library/windows/desktop/ms683226.aspx) を使用します。  
  
-   作業セットの上限と下限を取得するには、[GetProcessWorkingSetSize](http://msdn.microsoft.com/library/windows/desktop/ms686234.aspx) を使用します。  
  
-   作業セットのサイズを表示するには、Spy\+\+ を使用します。  
  
## 参照  
 [コードの最適化](../../build/reference/optimizing-your-code.md)