---
title: "インターフェイス (C + + CX) |Microsoft ドキュメント"
ms.custom: 
ms.date: 01/22/2017
ms.technology: cpp-windows
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: language-reference
ms.assetid: 11034314-d54a-426d-923b-5ab7a6b9f8ce
caps.latest.revision: 
author: ghogen
ms.author: ghogen
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: aa87713b49fe41dbdb7eb8f9e6382c8f78b51d0c
ms.sourcegitcommit: 6002df0ac79bde5d5cab7bbeb9d8e0ef9920da4a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/14/2018
---
# <a name="interfaces-ccx"></a>インターフェイス (C++/CX)
ref クラスは多くても 1 つの具象基底クラスからしか継承できませんが、任意の数のインターフェイス クラスを実装できます。 インターフェイス クラス (インターフェイス構造体) 自体は、複数のインターフェイス クラスを継承 (または要求) でき、メンバー関数をオーバーロードすることができ、型パラメーターを持つことができます。  
  
## <a name="characteristics"></a>特性  
 インターフェイスには、以下の特性があります。  
  
-   インターフェイス クラス (または構造体) は、名前空間内部で宣言される必要があり、その名前空間内で public または private のアクセシビリティを持つことができます。 パブリック インターフェイスだけがメタデータに出力されます。  
  
-   インターフェイスのメンバーには、プロパティ、メソッド、およびイベントを含めることができます。  
  
-   すべてのインターフェイス メンバーは、暗黙的にパブリックであり、仮想です。  
  
-   フィールドおよび静的メンバーは使用できません。  
  
-   値は、Windows ランタイム型を指定できますのみを返すまたはプロパティ、メソッド パラメーターとして使用される型これには、基本型と enum クラス型が含まれます。  
  
## <a name="declaration-and-usage"></a>宣言と使用法  
 インターフェイスの宣言方法を次に示します。 インターフェイスはクラス型または構造体型として宣言できます。  
  
 [!code-cpp[cx_interfaces#01](../cppcx/codesnippet/CPP/interfacestest/class1.h#01)]  
  
 インターフェイスを実装するには、ref クラスまたは ref 構造体で仮想メソッドと仮想プロパティを宣言し、実装します。 インターフェイスおよび ref クラスの実装では、この例に示すように、同じメソッド パラメーター名を使用する必要があります。  
  
 [!code-cpp[cx_interfaces#02](../cppcx/codesnippet/CPP/interfacestest/class1.h#02)]  
  
## <a name="interface-inheritance-hierarchies"></a>インターフェイス継承階層  
 インターフェイスは、1 つ以上のインターフェイスから継承できます。 ただし、ref クラスまたは ref 構造体とは異なり、インターフェイスは継承インターフェイス メンバーを宣言しません。 インターフェイス B がインターフェイス A から継承し、ref クラス C が B から継承する場合、C は A と B の両方を実装する必要があります。これを次の例に示します。  
  
 [!code-cpp[cx_interfaces#03](../cppcx/codesnippet/CPP/interfacestest/class1.h#03)]  
  
## <a name="implementing-interface-properties-and-events"></a>インターフェイスのプロパティとイベントの実装  
 前の例に示したように、単純な仮想プロパティを使用してインターフェイスのプロパティを実装できます。 また、実装するクラスでカスタムの get アクセス操作子および set アクセス操作子を提供できます。  インターフェイス プロパティで、get および set アクセス操作子が両方ともパブリックである必要があります。  
  
 [!code-cpp[cx_interfaces#04](../cppcx/codesnippet/CPP/interfacestest/class1.h#04)]  
  
 インターフェイスで取得専用または設定専用のプロパティを宣言する場合、実装するクラスは明示的に get または set アクセス操作子を提供する必要があります。  
  
 [!code-cpp[cx_interfaces#05](../cppcx/codesnippet/CPP/interfacestest/class1.h#05)]  
  
 また、実装するクラスでイベントのカスタムの追加および削除メソッドを実装できます。  
  
## <a name="explicit-interface-implementation"></a>明示的なインターフェイスの実装  
 ref クラスが複数のインターフェイスを実装し、それらのインターフェイスに名前と署名がコンパイラと同じメソッドがある場合、次の構文を使用して、クラス メソッドが実装しているインターフェイス メソッドを明示的に示すことができます。  
  
 [!code-cpp[cx_interfaces#06](../cppcx/codesnippet/CPP/interfacestest/class1.h#06)]  
  
## <a name="generic-interfaces"></a>ジェネリック インターフェイス  
 C + + CX、`generic`キーワードは、パラメーター化された Windows ランタイム型を表すために使用します。 パラメーター化された型は、メタデータに出力され、型パラメーターをサポートする言語で記述されたコードで利用できます。 Windows ランタイムは、一部のジェネリック インターフェイスを定義-たとえば、 [:ivector\<T >](Windows::Foundation::Collections::IVector)— C + のパブリック ユーザー定義ジェネリック インターフェイスの作成をサポートしていませんが、+ CX です。 ただし、プライベート ジェネリック インターフェイスは作成できます。  
  
 Windows ランタイム型を使用してジェネリック インターフェイスを作成する方法を次に示します。  
  
-   コンポーネント内のジェネリック ユーザー定義 `interface class` を Windows メタデータ ファイルに出力することはできません。したがって、パブリック アクセシビリティを持つことはできず、他の .winmd ファイル内のクライアント コードでは実装できません。 実装するには、同じコンポーネント内の非パブリック ref クラスを使用することが必要です。 パブリック ref クラスは、プライベート メンバーとしてジェネリック インターフェイス型を持つことができます。  
  
     次のコード スニペットは、ジェネリック `interface class` を宣言してから、プライベート ref クラスに実装し、その ref クラスをパブリック ref クラスのプライベート メンバーとして使用する方法を示します。  
  
     [!code-cpp[cx_interfaces#07](../cppcx/codesnippet/CPP/interfacestest/class1.h#07)]  
  
-   ジェネリック インターフェイスは、アクセシビリティ、メンバー、 *要求* リレーションシップ、基底クラスなどを管理する標準インターフェイス規則に従う必要があります。  
  
-   ジェネリック インターフェイスは、 `typename` または `class`を指定する 1 つ以上のジェネリック型パラメーターを受け取ることができます。 非型パラメーターはサポートされていません。  
  
-   型パラメーターには、任意の Windows ランタイム型を指定できます。 つまり、型パラメーターには、参照型、値の型、インターフェイス クラス、デリゲート、基本型、またはパブリック列挙型クラスを指定できます。  
  
-   *クローズ ジェネリック インターフェイス* は、ジェネリック インターフェイスから継承し、すべての型パラメーターに対して具象型引数を指定するインターフェイスです。 これは、非ジェネリック プライベート インターフェイスを使用できる場所のどこにでも使用できます。  
  
-   *オープン ジェネリック インターフェイス* は、具象型がまだ提供されていない 1 つ以上の型パラメーターを持つインターフェイスです。 これは型を使用できる場所のどこにでも使用できます。これには、別のジェネリック インターフェイスの型引数としての使用も含まれます。  
  
-   パラメーター化できるのは、個々のメソッドではなくインターフェイス全体だけです。  
  
-   型パラメーターを制約することはできません。  
  
-   クローズ ジェネリック インターフェイスには、暗黙的に生成される UUID があります。 ユーザーは UUID を指定できません。  
  
-   インターフェイスでは、メソッド パラメーター、戻り値、またはプロパティでの現在のインターフェイスへの参照は、現在のインスタンス化への参照と見なされます。 たとえば、 *IMyIntf*意味*IMyIntf\<T >*です。  
  
-   メソッド パラメーターの型が型パラメーターのとき、そのパラメーターまたは変数の宣言では、ポインター、ネイティブ参照、またはハンドル宣言子なしで型パラメーターの名前を使用します。 つまり、"T^" を作成することはありません。  
  
-   template 宣言された ref クラスは、プライベートである必要があります。 ジェネリック インターフェイスを実装でき、テンプレート パラメーターを渡すことができます*T*を汎用引数*T*です。テンプレート化された ref クラスの各インスタンス化は、それ自体が ref クラスです。  
  
## <a name="see-also"></a>参照  
 [型システム](../cppcx/type-system-c-cx.md)   
 [Visual C 言語リファレンス](../cppcx/visual-c-language-reference-c-cx.md)   
 [名前空間参照](../cppcx/namespaces-reference-c-cx.md)