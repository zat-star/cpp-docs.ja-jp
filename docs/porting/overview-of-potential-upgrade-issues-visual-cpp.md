---
title: "アップグレード時の潜在的な問題の概要 (Visual C++) | Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 2c99a8cb-098f-4a9d-bf2c-b80fd06ace43
caps.latest.revision: 
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: c3c01256e852f179d9f9cb02b5658898f5a1c96d
ms.sourcegitcommit: 9239c52c05e5cd19b6a72005372179587a47a8e4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/16/2018
---
# <a name="overview-of-potential-upgrade-issues-visual-c"></a>アップグレード時の潜在的な問題の概要 (Visual C++)

長年にわたり、Microsoft Visual C++ コンパイラでは、C++ 言語自体、C++ 標準ライブラリ、C ランタイム (CRT)、およびその他のライブラリ (MFC や ATL など) における変更と併せて、多くの変更が行われてきました。 その結果、Visual Studio の以前のバージョンからアプリケーションをアップグレードした場合、以前は正常にコンパイルされていたコードにおいてコンパイラおよびリンカーに関するエラーや警告が発生する場合があります。 元のコード ベースが古いほど、このようなエラーが発生する可能性は高くなります。 この記事では、発生する可能性が高い問題を最も一般的な方法で分類して概説するとともに、詳細情報へのリンクも示します。

注: 以前は、アップグレードが Visual Studio の複数のバージョンにまたがる場合には、1 度に 1 つずつ段階的にバージョンをアップグレードすることをお勧めしていました。 しかし、現在、この方法はお勧めしていません。 コード ベースの古さの程度に関係なく、ほとんどの場合は Visual Studio の最新バージョンへアップグレードする方がより簡単であることが判明しました。

アップグレード プロセスに関する質問またはコメントについては、vcupgrade@microsoft.com にお送りください。

## <a name="library-and-toolset-dependencies"></a>ライブラリとツールセットの依存関係

アプリケーションを Visual Studio コンパイラの新しいバージョンにアップグレードする場合は、アプリケーションがリンクしているすべてのライブラリおよび Dll もアップグレードすることを強くお勧めします。多くの場合は、この作業が必要となります。 そのためには、ソース コードへのアクセス権を持っているか、あるいは、ライブラリ ベンダーから、同じメジャー バージョンのコンパイラでコンパイルされた新しいバイナリ ファイルが提供されている必要があります。 この条件のいずれかを満たしている場合、バイナリの互換性について説明するこのセクションをスキップすることができます。 どちらの条件も満たしていない場合は、アップグレードされたアプリケーションでライブラリを使用できない可能性があります。 このセクションの情報を参照することで、アップグレードを続行することができるかどうかを判断することができます。

### <a name="toolset"></a>ツールセット

.obj および .lib ファイル形式は、適切に定義されており、変わることはほとんどありません。 時々これらのファイル形式には追加が行われる場合がありますが、この追加は一般には、新しいツールセットが以前のツールセットによって生成されたオブジェクト ファイルやライブラリを利用する機能に影響はありません。 ここで、1 つの重要な例外として、[/GL (プログラム全体の最適化)](../build/reference/gl-whole-program-optimization.md) を使用してコンパイルする場合が挙げられます。 **/GL** を使用してコンパイルした場合、その結果として生成されたオブジェクト ファイルをリンクするには、そのファイルの生成に使用したツールセットと同じものしか使用できません。 よって、**/GL** および Visual Studio 2017 (v141) コンパイラを使用してオブジェクト ファイルを生成する場合、生成されたファイルは Visual Studio 2017 (v141) リンカーを使用してリンクする必要があります。 このことは、オブジェクト ファイルの内部データ構造がツールセットのメジャー バージョン間で安定性がなく、新しいツールセットが以前のデータ形式を理解できないことに原因があります。

C++ のアプリケーション バイナリ インターフェイス (ABI) は安定性がありません。 Visual Studio では、リリースのすべてのマイナー バージョンについては安定した C++ ABI を維持しています。 たとえば、Visual Studio 2017 とそのすべての更新プログラムは、バイナリ互換性があります。 しかし、ABI は、Visual Studio のメジャー バージョン間では必ずしも互換性があるわけではありません (2015 と 2017 の場合は例外であり、_両者には_バイナリ互換性があります)。 つまり、弊社では、C++ の型レイアウト、名前の修飾、例外処理、または C++ ABI のその他の部分に重大な変更を加える場合があるということです。 したがって、C++ リンケージを使用した外部シンボルがオブジェクト ファイルに含まれている場合、そのオブジェクト ファイルは、ツールセットの異なるメジャー バージョンで生成されたオブジェクト ファイルと正しくリンクできないことがあります。 ここで、"機能しない場合がある" という表現には、リンクがまったく機能しないことがある (名前の修飾が変更された場合など)、リンクは正常であるが実行時に機能しないことがある (型のレイアウトが変更された場合など)、多くの場合はたまたま動作していると考えられ問題は発生しないなど、さまざまな意味が考えられます。 また、C++ ABI は安定していなくても、C ABI および COM に必要な C++ ABI のサブセットは安定性していることに注目してください。

インポート ライブラリにリンクすると、ABI との互換性を保持する、Visual Studio の再頒布可能ライブラリの新しいバージョンを実行時に使用することができます。 たとえば、アプリが Visual Studio 2015 Update 3 ツールセットを使用してコンパイルされ、リンクされている場合、すべての Visual Studio 2017 再頒布可能を使用することができます。これは、2015 と 2017 のライブラリでバイナリの下位互換性が保持されているためです。 その逆は当てはまりません。互換性のある ABI が含まれていても、コードのビルドに使用したツールセットよりも古いバージョンには再頒布可能を使用できません。

### <a name="libraries"></a>ライブラリ

特定のバージョンの Visual Studio C++ ライブラリ ヘッダー ファイルを使用してソース ファイルをコンパイルする場合 (ヘッダーを #including して)、結果として生成されるオブジェクト ファイルは、同じバージョンのライブラリとリンクする必要があります。 たとえば、Visual Studio 2017 2015 Update 3 \<immintrin.h> を使用してソース ファイルをコンパイルした場合は、Visual Studio 2015 Update 3 vcruntime ライブラリとリンクする必要があります。 同様に、Visual Studio 2017 バージョン 15.5 \<iostream> を使用してソース ファイルをコンパイルした場合は、Visual Studio 2017 バージョン 15.5 標準 C++ ライブラリである msvcprt とリンクする必要があります。 mixing-and-matching は、サポートされていません。

C++ 標準ライブラリについては、Visual Studio 2010 以降、標準ヘッダーに `#pragma detect_mismatch` を使用したことにより、mixing-and-matching は明示的に禁止されています。 互換性のないオブジェクト ファイルとのリンクを試みた場合、または誤った標準ライブラリとのリンクを試みた場合、リンクは失敗します。

CRT については、mixing-and-matching はサポートされていませんでしたが、少なくとも Visual Studio 2015 および Universal CRT までは、多くの場合、問題なく動作していました。これは、長い期間、API サーフェイスにあまり変更がなかったことによります。 Universal CRT では下位互換性の問題が解決され、将来的に下位互換性を維持できるようになりました。 すなわち、今後、バージョン管理の対象となる Universal CRT バイナリを新たに導入する計画はありません。 その代わり、既存の Universal CRT を適切に更新できるようになりました。

以前のバージョンの Microsoft C ランタイム ヘッダーでコンパイルされたオブジェクト ファイル (およびライブラリ) との部分的なリンク互換性を提供するために、弊社では Visual Studio 2015 以降のバージョンにライブラリ legacy_stdio_definitions.lib を提供しています。 このライブラリは、Universal CRT から削除された関数とデータ エクスポートの大部分に対して互換性シンボルを提供します。 legacy_stdio_definitions.lib によって提供される一連の互換性シンボルは、Windows SDK に含まれるライブラリ内のすべての依存関係を含む、ほとんどの依存関係を十分に満たしています。 ただし、Universal CRT から一部のシンボルは削除されています。それらについては、前述のように互換性シンボルになることはできません。 これらのシンボルには、いくつかの関数 (e.g., \_\_iob\_func) とデータ エクスポート (\_\_imp\_\_\_iob、\_\_imp\_\_\_pctype、\_\_imp\_\_\_mb\_cur\_max など) が含まれています。

以前のバージョンの C ランタイム ヘッダーでビルドされたスタティック ライブラリがある場合は、次の処理 (この順番で) をお勧めします。

1. Visual Studio 2017 および Universal CRT のヘッダーを使用してスタティック ライブラリをリビルドして、Universal CRT とのリンクをサポートします。 これは、完全にサポートされた (最適な) オプションです。

1. スタティック ライブラリをリビルドできない場合 (またはリビルドしたくない場合)、legacy\_stdio\_definitions.lib とのリンクを試みることができます。 それがスタティック ライブラリのリンク時の依存関係を満たしている場合は、スタティック ライブラリをバイナリ内で使用しながら十分にテストすることにより、スタティック ライブラリが [Universal CRT に加えられた動作関係の変更](visual-cpp-change-history-2003-2015.md#BK_CRT)のいずれからも悪影響を受けていないことを確認します。

1. legacy\_stdio\_definitions.lib がスタティック ライブラリの依存関係を満たしていない場合、または前途した動作関係の変更によりスタティック ライブラリが Universal CRT で動作しない場合は、Microsoft C ランタイムの正しいバージョンとリンクする DLL にスタティック ライブラリをカプセル化することをお勧めします。 たとえば、Visual Studio 2013 を使用してスタティック ライブラリがビルドされているならば、Visual Studio 2013 および Visual Studio 2013 C++ ライブラリを使用してこの DLL もビルドします。 DLL を生成してライブラリに取り込むことにより、特定のバージョンの Microsoft C ランタイムに対する依存関係を示す実装の詳細をカプセル化します  (DLL インターフェイスで、それがどの C ランタイムを使用しているかという詳細が漏れないように注意する必要があります。たとえば、DLL 境界を越えて FILE* を返したり、malloc で割り当てられたポインターを返して呼び出し元にそれを解放するよう求めたりすることにより、発生します。)

単一のプロセスで複数の CRT を使用することは、それ自体問題ではありません (実際に、ほとんどのプロセスでは最終的に複数の CRT DLL を読み込みます。たとえば、Windows オペレーティング システムのコンポーネントは msvcrt.dll に依存し、CLR は独自のプライベート CRT に依存します)。 さまざまな CRT からの状態を混ぜると、問題が発生します。 たとえば、msvcr110.dll!malloc でメモリを割り当ててから、msvcr120.dll!free でそのメモリの割り当て解除を試みたり、msvcr110!fopen で FILE を開いてから、msvcr120!fread でその FILE からの読み取りを試みたりしないでください。 さまざまな CRT からの状態を混ぜ合わせない限り、1 つのプロセスで複数の CRT を安全に読み込むことができます。

詳細については、「[Upgrade your code to the Universal CRT](upgrade-your-code-to-the-universal-crt.md)」 (コードを Universal CRT にアップグレードする) を参照してください。

## <a name="errors-due-to-project-settings"></a>プロジェクトの設定に起因するエラー

アップグレード プロセスを開始するには、Visual Studio の最新バージョンで以前のプロジェクト/ソリューション/ワークスペースを開くだけです。 Visual Studio は、以前のプロジェクトの設定に基づいて新しいプロジェクトを作成します。 以前のプロジェクトに、ライブラリが存在するか、または非標準的な場所にハードコーディングされたパスが存在する場合、それらのパス内のファイルは、プロジェクトで既定の設定が使用されていると、コンパイラに表示されない可能性があります。 詳細については、「[Linker OutputFile setting](porting-guide-spy-increment.md#linker_output_settings)」 (リンカーの OutputFile の設定) を参照してください。

全般的に見て、プロジェクト コードを適切に整理することにより、プロジェクトの保守を容易にすると共にアップグレードされたコードを可能な限りすばやくコンパイルできるようにするには今が絶好の機会です。 ソース コードがすでに適切に整理されていて、以前のプロジェクトが Visual Studio 2010 以降でコンパイルされている場合は、新旧両方のコンパイラでのコンパイルをサポートするように新しいプロジェクト ファイルを手動で編集することができます。 次の例では、Visual Studio 2015 および Visual Studio 2017 の場合のコンパイル方法を示します。

```xml
<PlatformToolset Condition="'$(VisualStudioVersion)'=='14.0'">v140</PlatformToolset>
<PlatformToolset Condition="'$(VisualStudioVersion)'=='15.0'">v141</PlatformToolset>
```

### <a name="lnk2019-unresolved-external"></a>LNK2019: 未解決の外部シンボル

未解決のシンボルの場合、プロジェクト設定の修正が必要なことがあります。

- ソース ファイルが既定以外の場所にある場合に、プロジェクトの include ディレクトリへのパスを追加しましたか?

- .lib ファイル内に外部シンボルが定義されている場合、プロジェクト プロパティ内に lib パスを指定していますか? また、そこには .lib ファイルの適切なバージョンが実際に置かれていますか?

- 異なるバージョンの Visual Studio でコンパイルされた .lib ファイルへのリンクを試みていますか? 試みている場合は、ライブラリとツールセットの依存関係に関する前のセクションを参照してください。

- 呼び出しサイトにおける引数の型は、関数の既存のオーバー ロードと実際に一致していますか? 関数のシグネチャ内で、および関数を呼び出すコード内で typedef の基になる型が、予期していたものと一致しているかどうかを確認します。

未解決シンボル エラーのトラブルシューティングを実行するには、dumpbin.exe を使用して、バイナリで定義されているシンボルを調べることができます。 次のコマンド ラインを試行して、ライブラリで定義されているシンボルを表示してください。

```cmd
dumpbin.exe /LINKERMEMBER somelibrary.lib
```

### <a name="zcwchart-wchart-is-native-type"></a>/Zc:wchar_t (wchar_t をネイティブ型として認識)

(Microsoft Visual C++ 6.0 以前では、`wchar_t` は、組み込み型として実装されていたのではなく、符号なし Short の typedef として wchar.h で宣言されていました)。C++ 標準では `wchar_t` は組み込み型とする必要があります。 typedef バージョンを使用すると、移植性の問題が発生することがあります。 以前のバージョンの Visual Studio からアップグレードしているとき、コードが `wchar_t` を `unsigned short` に暗黙的に変換しようとしたために C2664 コンパイル エラーが発生した場合は、**/Zc:wchar_t-** を設定するのではなく、コードを変更してエラーを修正することをお勧めします。 「[/Zc:wchar_t (wchar_t をネイティブ型として認識)](../build/reference/zc-wchar-t-wchar-t-is-native-type.md)」を参照してください。

### <a name="upgrading-with-the-linker-options-nodefaultlib-entry-and-noentry"></a>リンカー オプション /NODEFAULTLIB、/ENTRY、および /NOENTRY を使用したアップグレード

**/NODEFAULTLIB** リンカー オプション (または [すべての既定のライブラリの無視] リンカー プロパティ) は、CRT などの既定のライブラリ内で自動的にリンクしないようにリンカーに指示します。 これは、各ライブラリが、入力として個別にリストされる必要があることを意味します。 このライブラリ リストは、**[プロジェクトのプロパティ]** ダイアログの **[リンカー]** セクションにある **[追加の依存関係]** プロパティに指定されます。

このオプションを使用しているプロジェクトでは、アップグレード時に問題が発生します。これは、既定のいくつかのライブラリで名前の変更が行われていることが原因です。 各ライブラリは **[追加の依存関係]** プロパティ内か、またはリンカーのコマンドライン内にリストする必要があるため、現在の名前が使用されるようにライブラリのリストを更新する必要があります。

次の表に、Visual Studio 2015 以降、名前が変更されたライブラリを示します。 アップグレードするには、1 番目の列内の名前を、2 番目の列内の名前に置き換える必要があります。 これらのライブラリの一部はインポート ライブラリですが、そのことは重要ではありません。

|||
|-|-|
|次を使用していた場合|次のコード行への置き換えが必要|
|libcmt.lib|libucrt.lib、libvcruntime.lib|
|libcmtd.lib|libucrtd.lib、libvcruntimed.lib|
|msvcrt.lib|ucrt.lib、vcruntime.lib|
|msvcrtd.lib|ucrtd.lib、vcruntimed.lib|

また、**/ENTRY** オプションあるいは **/NOENTRY** オプションを使用する場合 (これらには既定のライブラリをバイパスする効果もある)、同じ問題が発生します。

## <a name="errors-due-to-improved-language-conformance"></a>言語の適合性強化に起因するエラー

Microsoft Visual C++ コンパイラは、長年にわたり、C++ 標準への適合性を強化し続けててきました。 以前のバージョンでコンパイルされたコードは、Visual Studio 2017 でコンパイルできない場合があります。これは、以前は無視または明示的に許容されていたエラーに適切にエラー フラグが付けられるようになったことによります。

たとえば、**/Zc:forScope** スイッチは、MSVC の歴史の早い段階で導入されました。 このスイッチでは、ループ変数に対する非準拠の動作が許可されます。 このスイッチは使用されなくなりました。将来のバージョンでは削除される可能性があります。 コードをアップグレードする際は、このスイッチを使用しないことを強く推奨します。 詳細については、「[/Zc:forScope- is deprecated](porting-guide-spy-increment.md#deprecated_forscope)」 (/Zc:forScope- は使用しないでください) を参照してください。

アップグレード時によく発生するコンパイラ エラーの例として、非 const 引数が const パラメーターに渡された場合に発生するエラーが挙げられます。 コンパイラの以前のバージョンでは、これに対して常にエラー フラグが付けられるわけではありませんでした。 詳細については、「[コンパイラのより厳密な変換](porting-guide-spy-increment.md#stricter_conversions)」を参照してください。

特定の適合性強化の詳細については、[Visual C++ change history 2003 - 2015](visual-cpp-change-history-2003-2015.md) (Visual C++ 2003 ～ 2015 での互換性に影響する変更点) および「[C++ conformance improvements in Visual Studio 2017](../cpp-conformance-improvements-2017.md)」 (Visual Studio 2017 での C++ 適合性強化) を参照してください。

## <a name="errors-involving-stdinth-integral-types"></a>\<stdint.h> 整数型に関連するエラー

\<stdint.h> ヘッダーでは、組み込みの整数型とは異なり、すべてのプラットフォームで指定の長さを保持することが保証される typedef および macro を定義します。 `uint32_t` と `int64_t` は、その例です。 \<stdint.h > ヘッダーは、Visual Studio 2010 で追加されました。 2010 より前に記述されたコードは、型に関するプライベート定義を備えている場合がありますが、それらの定義は \<stdint.h> 定義と常に整合するとは限りません。

エラー C2371 が発生し、stdint 型が関係している場合、その多くは、コード内またはサードパーティ製の lib ファイル内のヘッダー内でその型が定義されていることを意味します。 アップグレード時には、\<stdint.h> のカスタム定義を削除する必要がありますが、最初に、カスタム定義を現在の標準的な定義と比較して、新たな問題を招かないことを確認してください。

F12 キー (**定義へ移動**) を押すと、問題の型が定義されている場所を確認できます。

ここでは、[/showIncludes](../build/reference/showincludes-list-include-files.md) コンパイラ オプションが役に立ちます。 プロジェクトの **[プロパティ ページ]** ダイアログ ボックスで、**[C/C++]** > **[詳細設定]** ページの順に開き、**[インクルード ファイルの表示]** を **[はい]** に設定します。 次にプロジェクトをリビルドし、出力ウィンドウで #includes の一覧を確認します。 各ヘッダーは、それぞれが含まれているヘッダーの下にインデントされます。

## <a name="errors-involving-crt-functions"></a>CRT の関数に関係するエラー

C ランタイムには、長年にわたり、多くの変更が加えられてきました。 セキュリティで保護された関数のバージョンが多数追加された一方で、削除された関数もありました。 また、この記事で前述したように、Microsoft のRT 実装は、Visual Studio 2015 で新しいバイナリと関連する .lib ファイルにリファクタリングされました。

エラーが CRT 関数に関係している場合は、追加情報がないかどうか、「[Visual C++ 2003 ～ 2015 の変更履歴](visual-cpp-change-history-2003-2015.md)」または「[C++ conformance improvements in Visual Studio 2017](../cpp-conformance-improvements-2017.md)」 (Visual Studio 2017 での C++ 準拠の改善) を検索してください。 エラーが LNK2019 (未解決の外部シンボル) である場合は、関数が削除されていないことを確認してください。 関数がまだ存在し、呼び出し元のコードも正しい場合は、プロジェクトで **/NODEFAULTLIB** が使用されているかどうかを確認します。 それが使用されている場合は、プロジェクトで新しい Universal (UCRT) ライブラリを使用するように、ライブラリのリストを更新する必要があります。 ライブラリと依存関係の詳細については、上記セクションを参照してください。

エラーが `printf` または `scanf` 関数に関係している場合は、いずれの関数も stdio.h なしで非公開に定義されているのではないか確認してください。 そのように定義されている場合は、プライベート定義を削除するか、または legacy\_stdio\_definitions.lib へのリンクを削除します。 これを設定するには、**[プロパティ ページ]** ダイアログの **[追加の依存ファイル]** プロパティで **[構成プロパティ]** > **[リンカー]** > **[入力]** の順に選択します。 Windows SDK 8.1 以前のバージョンとリンクする場合は、legacy\_stdio\_definitions.lib を追加します。

エラーが書式文字列の引数に関係している場合は、おそらく、コンパイラが標準の適用に厳格であることが原因です。 詳細については、変更履歴を参照してください。 ここで取り上げたエラーは、セキュリティ上のリスクを招く可能性があるので、十分に注意してください。

## <a name="errors-due-to-changes-in-the-c-standard"></a>C++ 標準での変更によるエラー

C++ 標準自体、進化の過程で常に下位互換性が保たれていたわけではありませんでした。 C++11 での移動セマンティクス、新しいキーワード、および言語および標準ライブラリに関するその他の機能の導入は、コンパイラのエラーや異なるランタイム動作を引き起こす可能性があります。

たとえば、以前の C++ プログラムには、iostream.h ヘッダーが含まれている場合があります。 このヘッダーは、C++ の歴史の早い段階で使用されなくなり、最終的には Visual Studio から完全に削除されました。 前述の状況に該当する場合は、\<iostream> を使用してコードを書き直す必要があります。 詳細については、「[古い iostreams コードを更新する](porting-guide-spy-increment.md#updating_iostreams_code)」を参照してください。

### <a name="c4838-narrowing-conversion-warning"></a>C4838: 縮小変換に関する警告

C++ 標準では、符号なし整数値から符号付き整数値への変換を縮小変換と見なすように指定することになりました。 Visual Studio 2015 より前のコンパイラでは、この警告が通知されませんでした。 各警告の内容を調べて、コードの正確性に影響がないことを確認する必要があります。

## <a name="warnings-to-use-secure-crt-functions"></a>セキュリティで保護された CRT 関数を使用するように助言する警告

時間をかけて、C ランタイム関数のセキュリティで保護されたバージョンが導入されてきました。 セキュリティ保護されていない古いバージョンは引き続き使用できますが、セキュリティで保護されたバージョンを使用するようにコードを変更することをお勧めします。 セキュリティで保護されていないバージョンが使用されている場合は、コンパイラが警告を発行するようになります。 これらの警告は、無効にすることも無視することもできます。 ソリューション内のすべてのプロジェクトに対して警告を無効にするには、**[表示]** > **[プロパティ マネージャー]** の順に開き、警告を無効にするすべてのプロジェクトを選択し、選択した項目を右クリックして、**[プロパティ]** を選択します。 **[プロパティ ページ]** ダイアログで **[構成プロパティ]** > **[C/C++]** > **[詳細]** の順に選択し、**[指定の警告を無効にする]** を選択します。 ドロップダウン矢印をクリックし、**[編集]** をクリックします。 テキスト ボックスに「4996」と入力します  (プレフィックス "C" を含めないでください)。詳細については、「[Secure CRT を使用するよう移植する](porting-guide-spy-increment.md#porting_to_secure_crt)」を参照してください。

## <a name="errors-due-to-changes-in-windows-apis-or-obsolete-sdks"></a>Windows API または古い SDK での変更に起因するエラー

長年にわたり、Windows API とデータ型が追加されてきました。これらは変更されたり削除されたりすることもありました。 また、他にも、コア オペレーティング システムに付属していない SDK の中には登場しては消えていったものがあります。 そのため、古いプログラムには、もはや存在しない API の呼び出しが含まれている場合があります。 また、サポート対象外となった他の Microsoft SDK の API への呼び出しが含まれていることもあります。 Windows API または以前の Microsoft SDK の API に関連するエラーが発生した場合、API が削除されているか、またはセキュリティが強化された新しい関数に置き換えられている可能性があります。

現行の API セットについて、および特定の Windows API で最低限サポートされるオペレーティング システムについては、「[Microsoft API とリファレンスのカタログ](https://msdn.microsoft.com/library)」を参照し、該当する API に移動してください。

### <a name="windows-version"></a>Windows のバージョン

Windows API を直接または間接的に使用するプログラムをアップグレードする場合は、サポートする最低限の Windows バージョンを判断する必要があります。 ほとんどの場合は、Windows 7 が適切な選択となります。 詳細については、「[ヘッダー ファイルの問題](porting-guide-spy-increment.md#header_file_problems)」を参照してください。 WINVER マクロでは、プログラムを実行できる最も古い Windows バージョンが定義されます。 MFC プログラムで WINVER が 0x0501 (Windows XP) に設定されている場合、警告が表示されます。これは、コンパイラ自体は XP モードを備えているにもかかわらず、MFC で XP がサポートされなくなったことに原因があります。  

詳細については、「[ターゲットの Windows バージョンを更新する](porting-guide-spy-increment.md#updating_winver)」および「[その他の期限切れのヘッダー ファイル](porting-guide-spy-increment.md#outdated_header_files)」を参照してください。

## <a name="atl--mfc"></a>ATL/MFC

ATL および MFC は比較的安定した API ですが、変更が行われる場合があります。 詳細については、「[Visual C++ change history 2003 - 2015](visual-cpp-change-history-2003-2015.md)」 (Visual C++ 2003 ～ 2015 での互換性に影響する変更点)、「[What's New for Visual C++ in Visual Studio 2017](../what-s-new-for-visual-cpp-in-visual-studio.md)」 (Visual Studio 2017 での Visual C++ の新機能)、「[C++ conformance improvements in Visual Studio 2017](../cpp-conformance-improvements-2017.md)」 (Visual Studio 2017 での C++ 適合性強化) を参照してください。

### <a name="lnk-2005-dllmain12-already-defined-in-msvcrtdlib"></a>MSVCRTD.lib で定義済みの LNK 2005 _DllMain@12

このエラーは MFC アプリケーションで発生することがあります。 CRT ライブラリと MFC ライブラリの間での順序付けの問題を示します。 最初に MFC をリンクして、new および delete 演算子が提供されるようにする必要があります。 エラーを修復するには、/NODEFAULTLIB スイッチを使用して、既定のライブラリ MSVCRTD.lib と mfcs140d.lib を無視します。 次に、これらの lib を追加の依存関係として追加します。

## <a name="32-vs-64-bit"></a>32 ビットと 64 ビット

元のコードを 32 ビット システム用にコンパイルする場合は、新しい 32 ビット アプリの代わりに、または新しい 32 ビット アプリに加えて、64 ビット バージョンを作成することができます。 一般には、まずプログラムを 32 ビット モードでコンパイルしてから、64 ビット モードでのコンパイルを試みてください。 64 ビットのコンパイルは単純ですが、場合によって、32 ビットのビルドで隠れていたバグが明らかになることがあります。

また、ポインターのサイズ、時間、およびサイズ値、さらに printf 関数と scanf 関数での書式指定子に関連して発生する可能性のあるコンパイル時およびランタイムの問題にも注意する必要があります。 詳細については、「[64 ビット、x64 ターゲット用の Visual C++ の構成](../build/configuring-programs-for-64-bit-visual-cpp.md)」と「[Visual C++ の 64 ビットへの移行に関する一般的な問題](../build/common-visual-cpp-64-bit-migration-issues.md)」を参照してください。 移行に関する追加のヒントは、「[64 ビット Windows プログラミング ガイド](https://msdn.microsoft.com/library/windows/desktop/bb427430\(v=vs.85\).aspx)」を参照してください。

## <a name="unicode-vs-mbcsascii"></a>Unicode と MBCS/ASCII

Unicode が標準化される前、多くのプログラムでは、ASCII 文字セットに含まれていない文字を表現するためにマルチバイト文字セット (MBCS) が使用されていました。 古い MFC プロジェクトでは MBCS が既定の設定となっていました。しかし、そのようなプログラムをアップグレードすると、MBCS ではなく Unicode を使用するように助言する警告が表示されます。 Unicode への変換には開発コストをかけるだけの価値がないと判断した場合、警告は無効または無視してもかまいません。 ソリューション内のすべてのプロジェクトに対して警告を無効にするには、**[表示]** > **[プロパティ マネージャー]** の順に開き、警告を無効にするすべてのプロジェクトを選択し、選択した項目を右クリックして、**[プロパティ]** を選択します。 **[プロパティ ページ]** ダイアログ ボックスで、**[構成プロパティ]** > **[C/C++]** > **[詳細]** の順に選択します。 **[指定の警告を無効にする]** プロパティで、ドロップダウン矢印を開き、**[編集]** を選択します。 テキスト ボックスに「4996」と入力します  (プレフィックス "C" を含めないでください)。**[OK]** を選択してプロパティを保存し、**[OK]** を選択して変更を保存します。

詳細については、「[Porting from MBCS to Unicode](porting-guide-spy-increment.md#porting_to_unicode)」 (MBCS から Unicode に移植する) を参照してください。 MBCS と Unicode の一般的な情報については、「[Text and Strings in Visual C++](../text/text-and-strings-in-visual-cpp.md)」 (Visual C++ のテキストと文字列) と「[Internationalization](../c-runtime-library/internationalization.md)」 (国際化) を参照してください。

## <a name="see-also"></a>関連項目

[旧バージョンの Visual C++ からのプロジェクトのアップグレード](upgrading-projects-from-earlier-versions-of-visual-cpp.md)  
[Visual Studio 2017 の C++ 準拠の強化](../cpp-conformance-improvements-2017.md)  
